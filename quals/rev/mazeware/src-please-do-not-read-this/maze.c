#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <signal.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include "defs.h"
#include "rc4.h"

char key[] = {0x44, 0x55, 0x62, 0x1d, 0x5d, 0x46, 0xf9, 0x2c, 0x32, 0x5e, 0x62, 0x5f, 0xb5, 0x95, 0xf6, 0x9e, 0x67, 0x4b, 0x3a, 0x29, 0x98, 0x0c, 0x12, 0x90, 0x19, 0xe8, 0xc1, 0xb4, 0xf7, 0xa6, 0x0b, 0x22, 0x00};

char enc_sc[] = {0xb5, 0x01, 0x87, 0x08, 0x89, 0xe1, 0x05, 0xad, 0x03, 0xdf, 0x96, 0x16, 0xa5, 0x9f, 0xbf, 0x95, 0xf6, 0x9e, 0x2f, 0xca, 0xdd, 0x29, 0x68, 0xf3, 0x12, 0xd8, 0xde, 0x2e, 0xc1, 0xa4, 0xf7, 0xa6, 0x43, 0xe5, 0x86, 0x50, 0x62, 0x1d, 0x5d, 0x49, 0xfc, 0xc7, 0xe9, 0x16, 0xeb, 0xbf, 0xfd, 0x16, 0x36, 0x9a, 0x2f, 0xf0, 0xd5, 0x97, 0x35, 0xd2, 0x12, 0x90, 0x19, 0xe8, 0xf2, 0xac, 0x76, 0x5d, 0xee, 0x8d, 0xfa, 0x84, 0x17, 0xf5, 0xd6, 0x0e, 0x05, 0xaf, 0xcb, 0x5f, 0x16, 0x53, 0xfd, 0x2e, 0x19, 0x20, 0xca, 0x95, 0xd5, 0x97, 0x35, 0xd2, 0xed, 0x73, 0x49, 0xa0, 0x4c, 0x89, 0xf7, 0xa6, 0x0b, 0x22, 0x0c, 0x92, 0xa4, 0x1d, 0x4d, 0x46, 0xf9, 0x64, 0xc5, 0x88, 0x2a, 0xa0, 0x73, 0xdd, 0xd7, 0x69, 0x2f, 0x8c, 0xfa, 0x15, 0x98, 0x0c, 0x12, 0xd8, 0x9a, 0x00, 0xd5, 0xfc, 0x36, 0x4e, 0x09, 0x6a, 0x83, 0x93, 0x62, 0x0d, 0x5d, 0x46, 0xb1, 0xeb, 0xf0, 0x59, 0x62, 0x5f, 0xb5, 0x9a, 0xf3, 0xc6, 0x2e, 0x8c, 0xfd, 0x10, 0x98, 0x0c, 0x12, 0xf6, 0x92, 0xb8, 0x38, 0xfc, 0x49, 0x49, 0xb5, 0x8f, 0x9a, 0x55, 0x62, 0x1d, 0x5d, 0x0e, 0xc8, 0xde, 0x7a, 0x6f, 0xb8, 0x17, 0x3c, 0x46, 0x37, 0x7c, 0x62, 0x4a, 0xe9, 0x61, 0x5f, 0xca, 0x52, 0xc5, 0x59, 0xe8, 0x89, 0x85, 0x3e, 0xc0, 0x80, 0x2c, 0x0c, 0xaa, 0xa4, 0x55, 0xa2, 0x80, 0xb1, 0xa1, 0x0f, 0x5e, 0x62, 0x5f, 0xb5, 0xdc, 0x31, 0x5e, 0x65, 0x4b, 0x3a, 0x29, 0xd1, 0xf3, 0xda, 0xd8, 0xe6, 0x2f, 0x4a, 0xa3, 0x76, 0x5c, 0x3c, 0x31, 0xfa, 0xef, 0x17, 0xee, 0x10, 0xc3, 0x39, 0x59, 0xd9, 0x09, 0x9e, 0x0e, 0x46, 0x31, 0xaf, 0xc1, 0x30, 0x03, 0xfd, 0xe9, 0x98, 0x0c, 0x12, 0x90, 0x51, 0x2f, 0x03, 0xb4, 0xf7, 0xa6, 0x0b, 0x6a, 0x83, 0x93, 0x22, 0x4e, 0x1d, 0x46, 0xbd, 0xa7, 0x36, 0x58, 0x26, 0xd4, 0xb9, 0x82, 0xb3, 0xaf, 0xaf, 0x0a, 0x0b, 0xf1, 0xdc, 0x85, 0x16, 0x87, 0x51, 0x6b, 0x01, 0xb0, 0xbf, 0x25, 0xc9, 0x26, 0x0c, 0x6c, 0xa8, 0x6a, 0x52, 0x0e, 0x7a, 0xd4, 0x12, 0x2b, 0xb9, 0x17, 0x72, 0x55, 0xf6, 0x9e, 0x67, 0x4b, 0xd1, 0xfb, 0xd0, 0x81, 0x17, 0x60, 0xe6, 0x17, 0x3e, 0x3f, 0xef, 0xee, 0xf4, 0xea, 0xc5, 0xae, 0xa1, 0x40, 0xb6, 0xba, 0x8c, 0xdf, 0x7a, 0xd5, 0x3a, 0x10, 0xea, 0xdd, 0x7f, 0xc1, 0x65, 0x03, 0xfd, 0xea, 0xd8, 0x4c, 0x52, 0x90, 0x51, 0x61, 0xfa, 0xfc, 0x7a, 0x9b, 0xa9, 0xdc, 0xbb, 0xaa, 0x2a, 0x90, 0x50, 0xb4, 0x06, 0xd3, 0xcd, 0x16, 0x4b, 0xa6, 0xfd, 0x6a, 0x3f, 0x58, 0x60, 0x4b, 0x72, 0xa0, 0x66, 0x44, 0xed, 0x57, 0xe5, 0x1b, 0x65, 0xfc, 0x7a, 0x9b, 0x0b, 0x22, 0x44, 0x55, 0x2a, 0xda, 0x9b, 0x46, 0xe9, 0x2c, 0x32, 0x16, 0x95, 0x89, 0xfd, 0x6a, 0x30, 0xd6, 0x46, 0xbc, 0x72, 0xee, 0x58, 0x30, 0x12, 0x90, 0x19, 0xa0, 0x42, 0x5c, 0xe3, 0xee, 0xca, 0xca, 0x46, 0x1d, 0xa5, 0xdb, 0x5d, 0x56, 0xf9, 0x2c, 0x7a, 0x99, 0xa0, 0x5a, 0xb5, 0x95, 0xf6, 0x91, 0x62, 0x7c, 0x29, 0x97, 0x22};

char enc_sc2[] = {0x62, 0x03, 0xa1, 0xff, 0xf8, 0x52, 0x5d, 0x89, 0x63, 0x63, 0x32, 0x91, 0xe8, 0x7d, 0x50, 0x0d, 0x40, 0x27, 0xfb, 0x88, 0x07, 0x5b, 0xcd, 0x7c, 0x15, 0x65, 0xfc, 0x7a, 0x5c, 0x65, 0x12, 0x34, 0x86, 0x92, 0x9d, 0x60, 0x5f, 0x6f, 0x08, 0x00, 0xf8, 0xcc, 0xd7, 0xcc, 0xef, 0xfd, 0x6c, 0xa1, 0xcb, 0xec, 0x32, 0x1e, 0x3b, 0xf4, 0xdc, 0x38, 0x64, 0x61, 0xb4, 0xb1, 0x73, 0x82, 0x5b, 0xb7, 0x7e, 0xd3, 0xa0, 0xc7, 0xf8, 0xfe, 0x1b, 0x70, 0xc4, 0x1a, 0x58, 0x4d, 0x17, 0xae, 0x18, 0xcd, 0x00, 0x80, 0xcb, 0xb1, 0x55, 0x90, 0xf2, 0xda, 0x64, 0x61, 0xb4, 0xf9, 0xfd, 0xc6, 0x9d, 0xa5, 0x95, 0xde, 0xa1, 0x83, 0xd0, 0xe8, 0xf0, 0x57, 0x8c, 0x94, 0x1c, 0x88, 0x16, 0x45, 0x18, 0xcc, 0x3a, 0x90, 0x35, 0x5a, 0x4f, 0xd8, 0x35, 0x1d, 0x67, 0x30, 0xfc, 0x40, 0x4b, 0xba, 0xa5, 0xb7, 0x7e, 0xd3, 0xe9, 0x44, 0x46, 0xa4, 0x49, 0x57, 0xb0, 0x2d, 0x50, 0x4f, 0x17, 0xae, 0x18, 0xd5, 0xcb, 0xd6, 0x35, 0x55, 0x7f, 0xe4, 0x35, 0x1d, 0x67, 0x61, 0xe5, 0xb1, 0x0d, 0x49, 0xaa, 0x48, 0xb1, 0xd3, 0xe9, 0x44, 0x17, 0xbd, 0xb8, 0xee, 0x7f, 0xe1, 0x9c, 0x43, 0x17, 0xae, 0x18, 0x84, 0xd2, 0x27, 0x73, 0x66, 0x8f, 0xe8, 0xfa, 0x1d, 0x67, 0x61, 0xb4, 0xa8, 0xfc, 0xfc, 0xa6, 0x48, 0xb1, 0x20, 0xe9, 0x44, 0x17, 0xec, 0xa1, 0x1f, 0x35, 0xd1, 0xa3, 0x8f, 0x17, 0xae, 0x18, 0x84, 0x83, 0x3e, 0x82, 0xe3, 0x80, 0x17, 0xc6, 0xe1, 0x67, 0x61, 0xb4, 0xf9, 0xe5, 0x0d, 0xe3, 0x48, 0xa2, 0xef, 0xe5, 0x44, 0x17, 0xec, 0xf0, 0x06, 0xc4, 0x64, 0x9c, 0x8c, 0xdb, 0x41, 0x18, 0x84, 0x83, 0x6f, 0x9b, 0x12, 0xf6, 0xdb, 0x36, 0x12, 0x9b, 0x61, 0xb4, 0xf9, 0xb4, 0x14, 0x12, 0x0e, 0x81, 0x2c, 0x16, 0xbb, 0x17, 0xec, 0xf0, 0x57, 0xdd, 0x91, 0x16, 0xb7, 0x5f, 0x69, 0xd9, 0x94, 0x83, 0x6f, 0xca, 0xad, 0xbe, 0x48, 0x7d, 0xe2, 0xa7, 0x28, 0x3d, 0x38, 0xfd, 0xcc, 0x98, 0xf6, 0x26, 0x2c, 0x21, 0xc1, 0xd7, 0x99, 0x08, 0x86, 0x6e, 0x2a, 0x45, 0xcc, 0xd5, 0xb0, 0x51, 0x0d, 0x50, 0x27, 0x4f, 0x88, 0x3b, 0xd1, 0x7c, 0xcc, 0x8f, 0x9e, 0x7e, 0x7c, 0x66, 0x30, 0xad, 0xfe, 0xfd, 0x33, 0xea, 0x08, 0x9e, 0x24, 0xb8, 0xa0, 0x54, 0x95, 0x1c, 0x8f, 0x19, 0xef, 0x41, 0x7b, 0x4b, 0xea, 0x0a, 0x2f, 0xb7, 0x91, 0xb6, 0xe5, 0x65, 0x6e, 0x30, 0x45, 0xb4, 0x45, 0x5a, 0xfa, 0xfb, 0x13, 0xe6, 0xc1, 0x4e, 0xed, 0xf0, 0x57, 0xc4, 0x50, 0xa2, 0x4f, 0x17, 0xae, 0x18, 0xcc, 0x44, 0xa9, 0xca, 0x4a, 0x4f, 0xd8, 0x7d, 0xea, 0xb1, 0x29, 0x4b, 0x3f, 0xfc, 0x64, 0xad, 0xff, 0xb9, 0x13, 0xd5, 0x44, 0x17, 0xec, 0xb8, 0xd4, 0x64, 0xc9, 0xd7, 0x8e, 0xff, 0xac, 0x50, 0x43, 0x45, 0x6f, 0xda, 0x5a, 0x4f, 0x90, 0xf2, 0xdf, 0x60, 0x61, 0xb4, 0xf9, 0xf5, 0x16, 0x55, 0xb2, 0x3f, 0x88, 0xa1, 0x83, 0xd0, 0xed, 0xf0, 0x57, 0x8c, 0x90, 0x1a, 0x94, 0x63, 0xa5, 0x50, 0x55, 0x64, 0x26, 0x35, 0x91, 0x02, 0x5d, 0xee, 0x68, 0x92, 0x29, 0x39, 0xcc, 0xf4, 0xba, 0xa5, 0x48, 0x32, 0x5a, 0x38, 0x09, 0x26, 0x3e, 0xb8, 0x90, 0x4c, 0xd6, 0x9f, 0x4f, 0x17, 0xe6, 0xef, 0x65, 0xcb, 0x46, 0x0c, 0x12, 0xcc, 0x1e, 0x3e, 0x55, 0xec, 0x77, 0xfc, 0xf0, 0x4e, 0x0d, 0xd3, 0xa1, 0x36, 0x5e, 0xd4, 0x44, 0x17, 0xec, 0xf0, 0x1f, 0x4b, 0x1b, 0x9f, 0x5f, 0x17, 0xae, 0x50, 0x73, 0x55, 0x27, 0x35, 0x9c, 0x07, 0xf9, 0xc2, 0x55, 0xa0, 0xa1, 0x88, 0xf9, 0xb4, 0x45, 0x12, 0x34, 0x96, 0xc7, 0xa1, 0x85, 0xff, 0xee, 0xb8, 0x90, 0x4a, 0xdd, 0x8f, 0x4f, 0x17, 0xe6, 0xdf, 0x46, 0x86, 0x6f, 0xca, 0x5a, 0x40, 0xdd, 0xdc, 0x58, 0x66, 0x61, 0xb4, 0xb1, 0x39, 0x31, 0x7e, 0x2f, 0x36, 0x14, 0x28, 0x44, 0x17, 0xec, 0xf0, 0x1f, 0xbd, 0x1d, 0xd7, 0x7e, 0xc5, 0xe6, 0x93, 0x90, 0x0d, 0x27, 0xfb, 0x8a, 0x07, 0x19, 0xf5, 0x19, 0x2f, 0x9e, 0x75, 0xb1, 0x37, 0xbc, 0x4c, 0xc2, 0x92, 0x83, 0xa1, 0x83, 0xd7, 0xec, 0xb1, 0x17, 0x8c, 0x95, 0x58, 0x88, 0xd7, 0xee, 0x58, 0x84, 0xcb, 0xa8, 0x0b, 0x71, 0x4f, 0xd8, 0x35, 0x5d, 0xed, 0x15, 0xbb, 0x06, 0x3e, 0x11, 0x52, 0x48, 0x3e, 0xe3, 0x3f, 0x04, 0x9f, 0x98, 0xff, 0xa8, 0xc4, 0x22, 0x56, 0x07, 0x92, 0x67, 0x6d, 0x63, 0xdb, 0x27, 0xfb, 0x5e, 0x80, 0x90, 0xca, 0xdc, 0x2f, 0xe2, 0x4d, 0xfc, 0xc1, 0xb6, 0x0a, 0xff, 0x5b, 0x2c, 0xe9, 0x44, 0x17, 0xac, 0x7a, 0x63, 0x43, 0x9d, 0xaf, 0x89, 0x57, 0x26, 0x2c, 0x4b, 0xdb, 0x27, 0x0b, 0xb2, 0x47, 0x88, 0x7d, 0x38, 0x98, 0x61, 0xb4, 0xf9, 0xf4, 0xcf, 0x2e, 0x78, 0x7f, 0x93, 0xd9, 0x82, 0x57, 0x64, 0x84, 0x98, 0x8d, 0x85, 0xd7, 0x8e, 0xff, 0xa6, 0x50, 0xa1, 0x7c, 0x6f, 0xca, 0x5a, 0x0f, 0x52, 0x41, 0xd2, 0x65, 0x21, 0x84, 0x3f, 0xf4, 0xcd, 0x2e, 0x78, 0x7c, 0x9b, 0x64, 0x79, 0x17, 0xec, 0xf0, 0x57, 0xc4, 0x1a, 0x59, 0x4f, 0x07, 0xae, 0x18, 0xcc, 0x74, 0xb9, 0x82, 0xa5, 0x89, 0x90, 0x14, 0xea, 0x2f, 0xa6, 0x74, 0xc5, 0xb4, 0x45, 0x5a, 0xff, 0xfd, 0x3b, 0xfd, 0x0c, 0xd6, 0x04, 0xf2, 0x1f, 0x4b, 0x1b, 0x9f, 0x5f, 0x17, 0xae, 0x50, 0x43, 0x41, 0x68, 0xca, 0x5a, 0x4f, 0xd7, 0x30, 0x55, 0xea, 0x5c, 0xb2, 0x04, 0x4b, 0xba, 0x12, 0x3c, 0x49, 0x9b, 0x2e, 0x86, 0x57, 0xac, 0xb0, 0x57, 0xc4, 0x54, 0xad, 0x07, 0xe8, 0x61, 0x50, 0x7b, 0x4c, 0x27, 0x47, 0x6f, 0x5f, 0xd8, 0x35, 0x1d, 0x2f, 0x48, 0x4a, 0xb1, 0x3d, 0xb4, 0x12, 0x3e, 0x80, 0x9b, 0x16, 0x8b, 0x5f, 0x6b, 0x0e, 0xab, 0x7f, 0x79, 0xd7, 0xc2, 0x2a, 0xae, 0x18, 0x84, 0x83, 0x27, 0x0d, 0x9c, 0x4f, 0xc8, 0x35, 0x1d, 0x2f, 0x96, 0x62, 0xb1, 0x4b, 0x83, 0x12, 0x96, 0x89, 0x9b, 0x2e, 0x84, 0x2b, 0xec, 0xf0, 0x57, 0xc4, 0x5e, 0x77, 0x5b, 0x5f, 0x6f, 0xf0, 0x86, 0xcb, 0xa8, 0x0c, 0x5a, 0x5f, 0xd8, 0x35, 0x55, 0xa0, 0xa3, 0xb1, 0xf9, 0xb4, 0x45, 0x55, 0xb2, 0x36, 0x5a, 0x31, 0x87};

// https://www.youtube.com/watch?v=dQw4w9WgXcQ
// grey{h1dd3n_1n_pl41n51gh7_35ffcbede152a94e}

// TODO: change ptrace call to a syscall, so it is unhookable >:)
#define PRINTF_GOT "0x000000404038"
#define GETCHAR_GOT "0x000000404040"
#define PATCH_OFF "0x4e"

void win() {
	char* pt = malloc(sizeof(enc_fake_flag));
	RC4(key, enc_fake_flag, pt);
	puts(pt);
}

extern void evil();
__asm__ (
	".text\n"
	".global evil					\n"
	// prologue: preserve ret value of hijacked fn
	"evil:							\n"
	"	push 	rdi;				\n"

	"find_code_cave:					\n"
	"	mov		rbx, ["PRINTF_GOT"]		\n"
	"	and		rbx, 0xfffffffffffff000	\n"

	"code_cave_loop:					\n" // this entire loop finds a PAGE that has at least 0x200 bytes in code cave
	"	add		rbx, 0x1000				\n" // iterate through each page size
	"	mov		rdi, rbx				\n"
	"	sub		rdi, 1					\n"
	"	mov		rsi, rdi				\n"
	"	sub		rsi, 0x200				\n"
	"	mov 	rcx, 0x200				\n"
	"	std								\n"
	"	repe	cmpsb					\n" // compare that each of the last 0x200 bytes are the same
	"	jne		code_cave_loop;			\n" // this likely means that the last 0x200 bytes are NULL!

	"change_perm_cave:					\n"
	"	mov		rax, 1					\n"
	"	shl		rax, 3					\n"
	"	sub		rax, -2					\n"
	"	mov 	rdi, rbx				\n"
	"	sub		rdi, 0x1000				\n"
	"	mov		rsi, 0x1000				\n"
	"	mov		rdx, 7					\n"
	"	syscall							\n" // we can do a MMAP syscall to turn the code cave page RWX
	
	"	push	rbx 					\n"
	"	sub		rbx, 0x1000				\n"
	"find_start_cave:					\n"
	"	mov		r9, 10					\n"
	"find_start_cave_j:"
	"	test	r9, r9					\n" // ?_? this seems to attempt to find the start of the code cave
	"	je 		found_cave				\n"
	"	add		rbx, 0x10				\n"
	"	mov		rax, [rbx]				\n"
	"	test 	rax, rax				\n"
	"	jne		find_start_cave			\n"
	"	dec		r9						\n"
	"	jmp		find_start_cave_j		\n"
	"found_cave:						\n"
	"	mov		r10, rbx				\n"
	"	sub		r10, 0x90				\n"

	// write code into code cave
	"	mov		r15, ["GETCHAR_GOT"]	\n" // save address of libc getchar for later use
	"	lea		rdi, [enc_sc]			\n" // prepare our encrypted shellcode into rdi
	"	xor 	rcx, rcx				\n"
	"	mov		r8, rcx					\n"
	"	mov		cx, [rdi]				\n" // load length of shellcode into CX
	"	add		rdi, rcx				\n"
	"	inc		rdi						\n"
	"	inc		rdi						\n"
	"	lea		rsi, [key]				\n" // RSI = key
	"	neg		rcx						\n"
	"	xor		r9, r9					\n"

	"loop_load_sc:						\n"
	"	mov 	al, [rdi+rcx]			\n" // decrypt shellcode
	"	mov		dl, [rsi+r9]			\n"
	"	xor		al, dl					\n"
	"	mov		[r10+r8], al			\n"
	"	inc		rcx						\n"
	"	inc		r8						\n"
	"	inc		r9						\n"
	"	cmp		r9, 32					\n" // key[rcx % 0x20]
	"	jne		skip					\n"
	"	mov		r9, 0					\n"
	"skip:								\n"
	"	test	rcx, rcx				\n" // done patching!
	"	jnz		loop_load_sc			\n"
	"	mov		[r10+"PATCH_OFF"], r15	\n" // we patch getchar address into our shellcode so that it can jump to getchar

	"restore_perm_cave:					\n"
	"	pop		rbx						\n"
	"	mov		rax, 1					\n"
	"	shl		rax, 3					\n"
	"	sub		rax, -2					\n"
	"	mov 	rdi, rbx				\n"
	"	sub		rdi, 0x1000				\n"
	"	mov		rsi, 0x1000				\n"
	"	mov		rdx, 5					\n"
	"	syscall							\n" // convert our code cave page back into R-X

	// hook into the GOT
	"got_hook:							\n"
	"	add 	r10, 0x29				\n"
	"	mov		["GETCHAR_GOT"], r10	\n" // hook our shellcode into getchar@got

	"turn_text_executable:				\n"
	"	mov		rax, 127				\n" // we prepare to clean up our shellcode, we turn .text executable first
	"	and		rax, 15					\n"
	"	and		rax, 2					\n"
	"	or		rax, 8					\n"
	"	lea		rdi, main				\n"
	"	mov		r8, 0xfff				\n"
	"	not		r8						\n"
	"	and		rdi, r8					\n"
	"	mov		rsi, 0x1000				\n"
	"	mov		rdx, 7					\n"
	"	syscall							\n"

	// destroy the entire of evil and gadget
	// patch out entire gadgets stuff
	"cleanup:							\n"
	"	lea		rax, evil				\n"
	"	push	rax						\n"
	"	mov		rbx, rax				\n"
	"	mov		rcx, 0x837b7d94			\n"
	"	xor		rcx, 0x79657267			\n"
	"cleanup_loop:						\n" // this loop is used to find the end of the malicious rop chain
	"	add		rax, 1					\n"
	"	cmp		ecx, [rax]				\n"
	"	jne		cleanup_loop			\n"
	"	sub		rax, rbx				\n"
	"	push	rax						\n"

	// find location to patch
	"	lea		rax, print_maze			\n"
	"find_ret:							\n" // this loop is used to find the ret hijacking instructions for patching
	"	inc		rax						\n"
	"	mov		edx, [rax]				\n"
	"	xor		edx, 0xdeadbeef			\n"
	"	cmp		edx, 0x1d4dfb64			\n"
	"	jne		find_ret				\n"

	// 1. patch secret return hijacking
	"patch_ret:							\n"
	"	push	0xf						\n"
	"	mov		r8, 0x52c8948			\n"
	"	shl		r8, 32					\n"
	"	push	0xa000000				\n"
	"	pop		r9						\n"
	"	or		r8, r9					\n"
	"	push	r8						\n"
	"	mov		rcx, 0					\n"
	"	jmp a							\n"

	"patch_loop:						\n"
	"	inc		rcx						\n"	
	"a:									\n"
	"	mov		sil, [rax+rcx]			\n"
	"	mov		dil, [rsp+rcx]			\n"
	"	xor		sil, dil				\n"
	"	mov		[rax+rcx], sil			\n"
	"	cmp		rcx, 9					\n"
	"	jne		patch_loop				\n"

	" 	sub 	rax, 0x7				\n"
	"	mov 	rdi, 0x8b				\n"
	"	mov		rcx, 0x90				\n"
	"   shl		rdi, 8					\n"
	"	or		rdi, rcx				\n"
	"   shl		rdi, 8					\n"
	"	or		rdi, rcx				\n"
	"   shl		rdi, 8					\n"
	"	or		rdi, rcx				\n"
	"   shl		rdi, 8					\n"
	"	or		rdi, rcx				\n"
	"   shl		rdi, 8					\n"
	"	or		rdi, rcx				\n"
	"   shl		rdi, 8					\n"
	"	or		rdi, rcx				\n"
	"   shl		rdi, 8					\n"
	"	or		rdi, rcx				\n"
	"	mov		[rax], rdi				\n"

	// 2. now we NULL the entire gadgets
	"destroy:							\n"
	"	add		rsp, 0x10				\n"
	"	pop		rcx						\n" // size
	"	pop		rdi						\n" // nul dest
	"	sub		rsp, 0x8				\n"
	"	pop		rsi						\n"
	"	add		rdi, 1					\n"
	"	xor 	rax, rax				\n"
	"	mov		[rsi], al				\n"
	"	dec		rcx						\n"
	"	cld								\n"
	"	sub		r10, 0x22				\n"
	"	push	r10						\n" // <-- we can obfuscate this further by pushing it earlier
	"	ret								\n"

);

extern void gadget();
// TODO: TURN THIS INTO A ROP CHAIN!
__asm__ (".text\n.global gadget        \n"
         "gadget:               \n"
         "  pop       rax       \n"
         "  mov       rsp, rbp  \n"
         "  jmp		  rax       \n");
void * gadgets[] = {gadget, evil};

uint16_t get_x_y(char* maze) {
	uint8_t x = *(maze+3);
	uint8_t y = *(maze+1);
	return (uint16_t)((x<<8) | y);
}

bool check_valid_pos(char* maze, int x, int y) {
	uint8_t w = *(maze+4);
	uint8_t h = *(maze+5);
	int c = y * w + x;
	uint8_t byt = *(maze+6+c/8);
	return (((byt >> (7-(c%8))) & 1) == false);
}

int print_maze(char* maze, int start_x, int start_y) {
	printf(CLRSCR "\n\n\n");
	printf("\tW A S D to navigate\n");
	int flag_y = *(int8_t*)maze;
	int flag_x = ((int8_t*)maze)[2];
	if ((start_x == -1) && (start_y == -1)) {
		start_y = ((int8_t*)maze)[1];
		start_x = ((int8_t*)maze)[3];
	}
	int width = ((int8_t*)maze)[4];
	int height = ((int8_t*)maze)[5];

	// size = width * height;
	int size = 0;
	for (int i = 0; i < width; i++, size += height);

	int flag_pos = flag_y * width + flag_x;
	int start_pos = start_y * width + start_x;
	int cur = 0;
	uint8_t byte = ((uint8_t*)maze)[6+cur/8];
	int ret = 0;

	printf("\t");
	for (int i = 0; i < size; i++) {
		byte = ((uint8_t*)maze)[6+cur/8];
		bool wall = (byte >> (7-(cur % 8))) & 1;
		if (cur == start_pos) {
			if (cur == flag_pos)
				ret = 1;
			putchar('^');
		}
		else if (cur == flag_pos) {
			putchar('F');
		}
		else if (wall) {
			putchar('#');
		} else {
			putchar(' ');
		}
		cur += 1;
		if (!(cur % width)) {
			printf("\n\t");
		}
	}
	__asm__(
		"mov rsp, %0;\n"
		"mov eax, [rbp-0x20];\n"
		"ret;" // we could turn this to send some signal to ptrace :)
		:
		:"i"(gadgets)
	);
	return ret;
}

void maze() {

	int marker = 0xf13110a;
	for (int lvl = 0; lvl < 3; lvl++) {

		uint8_t x = get_x_y(mazes[lvl]) >> 8;
		uint8_t y = get_x_y(mazes[lvl]) & 0xf;
		print_maze(mazes[lvl], x, y);
		

		while (1) {

			uint8_t c = (uint8_t)getchar();
			if (c >= 97) {
				c -= 32;
			}

			if (c < 65) {
				;
			} else {
				c -= 65;
				if (c) {
					if (!((c / 3) - (c % 3) - 1)) {
						if (check_valid_pos(mazes[lvl], x+1, y))
							++x;
					} else {
						c -= 18;
						if (!c) {
							if (check_valid_pos(mazes[lvl], x, y+1))
								++y;
						} else {
							if (c == 4) {
								if (check_valid_pos(mazes[lvl], x, y-1))
									--y;
							}
						}
					}
				} else {
					if (check_valid_pos(mazes[lvl], x-1, y))
						--x;
				}
			}

			if (print_maze(mazes[lvl], x, y)) {
				printf("\n\tNext level? Enter to continue...");
				getchar();
				getchar();
				lvl += 1;
				if (lvl == 3) {
					win();
					break;
				}
				x = get_x_y(mazes[lvl]) >> 8;
				y = get_x_y(mazes[lvl]) & 0xf;
				print_maze(mazes[lvl], x, y);
			}

		}

	}

}

void init_debugger() {

	// while (1) {
	// waitpid(pid, &status, 0);
	// }

	return;
}

int main() {

	// pid_t pid = fork();
	//
	// if (pid) {
	// 	init_debugger(pid);
	// } else {
	// 	if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1) {
	// 		exit(0);
	// 	}
	// 	maze();
	// }
	printf("%s", BANNER);
	getchar();
	maze();
	
}

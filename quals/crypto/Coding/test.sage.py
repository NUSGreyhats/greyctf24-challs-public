

# This file was *autogenerated* from the file test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_100 = Integer(100); _sage_const_2 = Integer(2); _sage_const_0p05 = RealNumber('0.05'); _sage_const_6 = Integer(6); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_100000 = Integer(100000); _sage_const_1000 = Integer(1000)
from secrets import randbelow
import numpy as np
from ldpc import bp_decoder, code_util
from sage.coding.information_set_decoder import LeeBrickellISDAlgorithm
import random

n = _sage_const_100 
k = int(n * _sage_const_2 )
threshold = _sage_const_0p05 
tt = _sage_const_6 
arr = [_sage_const_1 ] * tt + [_sage_const_0 ] * (k - tt)

H = []

for i in range(k - n):
    temp = []
    random.shuffle(arr)
    H.append(arr.copy())

H = np.array(H)
G = code_util.construct_generator_matrix(H)

G = G.transpose()
np.random.shuffle(G)
G = G.transpose()

np.random.shuffle(G)

C = LinearCode(Matrix(GF(_sage_const_2 ), G))
H = C.parity_check_matrix().change_ring(ZZ).LLL().change_ring(GF(_sage_const_2 )).numpy(dtype=int)

bpd=bp_decoder(
    H, #the parity check matrix
    error_rate=threshold, # the error rate on each bit
    max_iter=_sage_const_100000 , #the maximum iteration depth for BP
    bp_method="product_sum", #BP method. The other option is `minimum_sum'
    channel_probs=[None] #channel probability probabilities. Will overide error rate.
)

# Weight 1

dic = {}

error = np.zeros(k,dtype=int)
key = tuple(list(H @ error.transpose() % _sage_const_2 ))
dic[key] = [error]

for i in range(k):
    error = np.zeros(k,dtype=int)
    error[i] = _sage_const_1 
    key = tuple(list(H @ error.transpose() % _sage_const_2 ))
    if (key not in dic):
        dic[key] = []
    dic[key].append(error)

# Weight 2

for i in range(k):
    for j in range(i + _sage_const_1 , k):
        error = np.zeros(k,dtype=int)
        error[i] = _sage_const_1 
        error[j] = _sage_const_1 
        key = tuple(list(H @ error.transpose() % _sage_const_2 ))
        if (key not in dic):
            dic[key] = []
        dic[key].append(error)

# Weight 3

for i in range(k):
    for j in range(i + _sage_const_1 , k):
        for l in range(j + _sage_const_1 , k):
            error = np.zeros(k,dtype=int)
            error[i] = _sage_const_1 
            error[j] = _sage_const_1 
            error[l] = _sage_const_1 
            key = tuple(list(H @ error.transpose() % _sage_const_2 ))
            if (key not in dic):
                dic[key] = []
            dic[key].append(error)

count = _sage_const_0 
for _ in range(_sage_const_100 ):

    m = [randbelow(_sage_const_2 ) for _ in range(n)]
    m = np.array(m)

    original = m @ G % _sage_const_2 

    noise = [_sage_const_0  for _ in range(k)]

    for i in range(k):
        if (randbelow(_sage_const_1000 ) / _sage_const_1000 ) < threshold:
            noise[i] = _sage_const_1 

    noise = np.array(noise)

    print(sum(noise))

    encoded = (original + noise) % _sage_const_2 

    decoded_codeword = bpd.decode(encoded)

    print(sum(decoded_codeword != original))

    key = tuple(list(H @ decoded_codeword.transpose() % _sage_const_2 ))

    if (key in dic):
        ttt = _sage_const_0 
        for i in range(len(dic[key])):
            temp = (decoded_codeword + dic[key][i]) % _sage_const_2 
            try:
                guess = Matrix(GF(_sage_const_2 ), G).solve_left(vector(GF(_sage_const_2 ), temp))
                ttt += _sage_const_1 
                if (vector(GF(_sage_const_2 ), m) == guess):
                    count += _sage_const_1 
                    print("Success", ttt)
                    break
            except KeyboardInterrupt:
                exit()
            except:
                pass
            
        else:
            print("Failure")
    else:
        print("Failure")
    
print(count/_sage_const_100 )


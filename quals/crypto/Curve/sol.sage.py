

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6)
from param import p, n, b
from hashlib import shake_128

load('output.sage')

A = []
vec = []

for i in range(len(factors)):
    g = output[i][_sage_const_0 ]
    h = output[i][_sage_const_4 ]
    b1 = F1(b)
    b2 = F2(output[i][_sage_const_4 ][_sage_const_1 ])**_sage_const_2  - F2(output[i][_sage_const_4 ][_sage_const_0 ])**_sage_const_3 

    E1 = EllipticCurve(GF(p), [_sage_const_0 , b1])
    E2 = EllipticCurve(F2, [_sage_const_0 , b2])

    t = b1 / b2

    if (t**((p**_sage_const_2  - _sage_const_1 )/_sage_const_3 ) == _sage_const_1  or t**((p**_sage_const_2  - _sage_const_1 )/_sage_const_2 ) == _sage_const_1 ):
        print(i)
        continue

    if (E2.cardinality() % n != _sage_const_0 ):
        print(i)
        continue

    h = E2.cardinality() // n

    P = E1(output[i][_sage_const_2 ][_sage_const_0 ], output[i][_sage_const_2 ][_sage_const_1 ])
    Q = h * E2(output[i][_sage_const_5 ][_sage_const_0 ], output[i][_sage_const_5 ][_sage_const_1 ])

    R = E1(output[i][_sage_const_3 ][_sage_const_0 ], output[i][_sage_const_3 ][_sage_const_1 ])
    S = h * E2(output[i][_sage_const_4 ][_sage_const_0 ], output[i][_sage_const_4 ][_sage_const_1 ])

    G = F2['x']; (x,) = G._first_ngens(1)
    F3 = F2.extension(x**_sage_const_6  - t, names=('v',)); (v,) = F3._first_ngens(1)

    E3 = EllipticCurve(F3, [_sage_const_0 , b])

    P = E3(P)
    Q = E3(v**_sage_const_2  * Q[_sage_const_0 ] , v**_sage_const_3  * Q[_sage_const_1 ])

    R = E3(R)
    S = E3(v**_sage_const_2  * S[_sage_const_0 ] , v**_sage_const_3  * S[_sage_const_1 ])

    A.append(factors[i])
    if (P.tate_pairing(Q, Integer(n), _sage_const_6 ) == R.tate_pairing(S, Integer(n), _sage_const_6 )):
        print(_sage_const_0 )
        vec.append(_sage_const_0 )
    else:
        print(_sage_const_1 )
        vec.append(_sage_const_1 )

def decrypt(msg, key):
    y = shake_128("".join(map(str, key)).encode()).digest(len(msg))
    return bytes([msg[i] ^ y[i] for i in range(len(msg))])

print(len(A))
key = map(int, Matrix(GF(_sage_const_2 ), A).solve_right(vector(GF(_sage_const_2 ), vec)))

print(decrypt(bytes.fromhex(c), key))


